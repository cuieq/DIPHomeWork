                          <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>TIFFRGBAImage(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
TIFFRGBAImage - read and decode an image into
a raster 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<br>
<pre>#include &lt;tiffio.h&gt;typedef unsigned char TIFFRGBValue;typedef struct _TIFFRGBAImage
TIFFRGBAImage;int TIFFRGBAImageOK(TIFF* tif, char emsg[1024]);int TIFFRGBAImageBegin(TIFFRGBAImage*
img, TIFF* tif, int stopOnError, char emsg[1024]);int TIFFRGBAImageGet(TIFFRGBAImage*
img, uint32* raster, uint32 width, uint32 height);void TIFFRGBAImageEnd(TIFFRGBAImage*
img);DescriptionThe routines described here provide a high-level interface
through which TIFF images may be read into memory. Images may be strip- or
tile-based and have a variety of different characteristics: bits/sample,
samples/pixel, photometric, etc. Decoding state is encapsulated in a TIFFRGBAImage
structure making it possible to capture state for multiple images and quickly
switch between them. The target raster format can be customized to a particular
application&rsquo;s needs by installing custom routines that manipulate image
data according to application requirements. The default usage for these
routines is: check if an image can be processed using TIFFRGBAImageOK,
construct a decoder state block using TIFFRGBAImageBegin, read and decode
an image into a target raster using TIFFRGBAImageGet, and then release
resources using TIFFRGBAImageEnd. TIFFRGBAImageGet can be called multiple
times to decode an image using different state parameters. If multiple images
are to be displayed and there is not enough space for each of the decoded
rasters, multiple state blocks can be managed and then calls can be made
to TIFFRGBAImageGet as needed to display an image. 
The generated raster
is assumed to be an array of width times height 32-bit entries, where width
must be less than or equal to the width of the image (height may be any
non-zero size). If the raster dimensions are smaller than the image, the
image data is cropped to the raster bounds. If the raster height is greater
than that of the image, then the image data are placed in the lower part
of the raster. (Note that the raster is assume to be organized such that
the pixel at location (x,y) is raster[y*width+x]; with the raster origin
in the  lower-left hand corner.) 
Raster pixels are 8-bit packed red, green,
blue, alpha samples. The macros TIFFGetR, TIFFGetG, TIFFGetB, and TIFFGetA
should be used to access individual samples. Images without Associated Alpha
matting information have a constant Alpha of 1.0 (255). 
TIFFRGBAImageGet
converts non-8-bit images by scaling sample values. Palette, grayscale, bilevel,
 CMYK, and YCbCr images are converted to RGB transparently. Raster pixels
are returned uncorrected by any colorimetry information present in the
directory. 
The paramater stopOnError specifies how to act if an error is
encountered while reading the image. If stopOnError is non-zero, then an
error will terminate the operation; otherwise TIFFRGBAImageGet will continue
processing data until all the possible data in the image have been requested.

Alternate Raster FormatsTo use the core support for reading and processing
 TIFF images, but write the resulting raster data in a different format
one need only override the &lsquo;&lsquo;put methods&rsquo;&rsquo; used to store raster data. These
methods are are defined in the TIFFRGBAImage structure and initially setup
by TIFFRGBAImageBegin to point to routines that pack raster data in the
default ABGR pixel format. Two different routines are used according to
the physical organization of the image data in the file:  PlanarConfiguration=1
(packed samples), and  PlanarConfiguration=2 (separated samples). Note that
this mechanism can be used to transform the data before storing it in the
raster. For example one can convert data to colormap indices for display
on a colormap display. Simultaneous Raster Store and DisplayIt is simple
to display an image as it is being read into memory by overriding the put
methods as described above for supporting alternate raster formats. Simply
keep a reference to the default put methods setup by TIFFRGBAImageBegin
and then invoke them before or after each display operation. For example,
the tiffgt(1) utility uses the following put method to update the display
as the raster is being filled: 
static void
putContigAndDraw(TIFFRGBAImage* img, uint32* raster,
    uint32 x, uint32 y, uint32 w, uint32 h,
    int32 fromskew, int32 toskew,
    unsigned char* cp)
{
    (*putContig)(img, raster, x, y, w, h, fromskew, toskew, cp);
    if (x+w == width) {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;w = width;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;if (img-&gt;orientation == ORIENTATION_TOPLEFT)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    lrectwrite(0, y-(h-1), w-1, y, raster-x-(h-1)*w);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;else
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    lrectwrite(0, y, w-1, y+h-1, raster);
    }
}
</pre><p>
(the original routine provided by the library is saved in the variable
 <i>putContig</i>.) 
<h2><a name='sect5' href='#toc5'>Supporting Additional Tiff Formats</a></h2>
The <i>TIFFRGBAImage</i> routines
support the most commonly encountered flavors of <font size='-1'>TIFF.</font>
 It is possible to
extend this support by overriding the &lsquo;&lsquo;<i>get method</i>&rsquo;&rsquo; invoked by <i>TIFFRGBAImageGet</i>
to read  <font size='-1'>TIFF</font>
 image data. Details of doing this are a bit involved, it is
best to make a copy of an existing get method and modify it to suit the
needs of an application. 
<h2><a name='sect6' href='#toc6'>Notes</a></h2>
Samples must be either 1, 2, 4, 8, or 16 bits.
Colorimetric samples/pixel must be either 1, 3, or 4 (i.e. <i>SamplesPerPixel</i>
minus <i>ExtraSamples</i>). <p>
Palettte image colormaps that appear to be incorrectly
written as 8-bit values are automatically scaled to 16-bits. 
<h2><a name='sect7' href='#toc7'>Return Values</a></h2>
All
routines return 1 if the operation was successful. Otherwise, 0 is returned
if an error was encountered and <i>stopOnError</i> is zero. 
<h2><a name='sect8' href='#toc8'>Diagnostics</a></h2>
All error
messages are directed to the <a href='TIFFError.3.html'><i>TIFFError</i>(3)</a>
 routine. <p>
<b>Sorry, can not handle
%d-bit pictures</b>. The image had <i>BitsPerSample</i> other than 1, 2, 4, 8, or 16.
<p>
<b>Sorry, can not handle %d-channel images</b>. The image had <i>SamplesPerPixel</i> other
than 1, 3, or 4. <p>
<b>Missing needed "PhotometricInterpretation" tag</b>. The image
did not have a tag that describes how to display the data. <p>
<b>No "PhotometricInterpretation"
tag, assuming RGB</b>. The image was missing a tag that describes how to display
it, but because it has 3 or 4 samples/pixel, it is assumed to be <font size='-1'>RGB.</font>
 <p>
<b>No
"PhotometricInterpretation" tag, assuming min-is-black</b>. The image was missing
a tag that describes how to display it, but because it has 1 sample/pixel,
it is assumed to be a grayscale or bilevel image. <p>
<b>No space for photometric
conversion table</b>. There was insufficient memory for a table used to convert
image samples to 8-bit <font size='-1'>RGB.</font>
 <p>
<b>Missing required "Colormap" tag</b>. A Palette image
did not have a required <i>Colormap</i> tag. <p>
<b>No space for tile buffer</b>. There was
insufficient memory to allocate an i/o buffer. <p>
<b>No space for strip buffer</b>.
There was insufficient memory to allocate an i/o buffer. <p>
<b>Can not handle
format</b>. The image has a format (combination of <i>BitsPerSample</i>, <i>SamplesPerPixel</i>,
and <i>PhotometricInterpretation</i>) that can not be handled. <p>
<b>No space for B&amp;W
mapping table</b>. There was insufficient memory to allocate a table used to
map grayscale data to <font size='-1'>RGB.</font>
 <p>
<b>No space for Palette mapping table</b>. There was
insufficient memory to allocate a table used to map data to 8-bit <font size='-1'>RGB.</font>
 
<h2><a name='sect9' href='#toc9'>See
Also</a></h2>
<a href='libtiff.3.html'><i>libtiff</i>(3)</a>
, <a href='TIFFOpen.3.html'><i>TIFFOpen</i>(3)</a>
, <a href='TIFFReadRGBAImage.3.html'><i>TIFFReadRGBAImage</i>(3)</a>
, <a href='TIFFReadRGBAImageOriented.3.html'><i>TIFFReadRGBAImageOriented</i>(3)</a>
,
<a href='TIFFReadRGBAStrip.3.html'><i>TIFFReadRGBAStrip</i>(3)</a>
, <a href='TIFFReadRGBATile.3.html'><i>TIFFReadRGBATile</i>(3)</a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Alternate Raster Formats</a></li>
<li><a name='toc4' href='#sect4'>Simultaneous Raster Store and Display</a></li>
<li><a name='toc5' href='#sect5'>Supporting Additional Tiff Formats</a></li>
<li><a name='toc6' href='#sect6'>Notes</a></li>
<li><a name='toc7' href='#sect7'>Return Values</a></li>
<li><a name='toc8' href='#sect8'>Diagnostics</a></li>
<li><a name='toc9' href='#sect9'>See Also</a></li>
</ul>
</body>
</html>
